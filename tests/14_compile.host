

; simple, primitive, atomic expression
compile 1 === 1


; single js function call with primitive arguments 
compile: log 1
_.toString! 
=== "function (){ctx._ = fn.apply(fnContext,items); return ctx._;}"


; match an object
;*
` log 1
==~ : list ` (new name~"log" type~"Fnjs") 1
new name~"log" type~"Fnjs"
new num~: 1 + 1 ^ name~: "Mark" + " Archer"
*;


; compile to lisp syntax
convertToLisp
    add
    1 ; number
    "string"
    add 1 2
    multiply _ 1
        1 + 2 3 / 4
    stuff n 5 >> n b.1
    , 1 2
    n~1 ; meta
    n[*Int] ; meta
    <<
        1 + 1
        >> * 2
    each (range 2) i: print i
    >> each i: print i
=== : js "* `(add 1 "string" 
 (add 1 2) 
 (multiply _ 1 
    (divide 
        (add 1 2 3) 4)) 
 (stuff n 5) 
 (n _ 
    (getr 
        (b 1))) 
 (list 1 2) 
 (new2 
    (name "n") 
    (type "Meta") 
    (value 1)) 
 (new2 
    (name "n") 
    (type "Meta") 
    (value_type Int) 
    (isList true)) 
 (evalBlock 
    (add 1 1) 
    (multiply _ 2)) 
 (each 
    (range 2) i 
    (print i)) 
 (each _ i 
    (print i)))`.trim().replace('\r\n','\n')*"