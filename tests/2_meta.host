;; special symbols
?name
=== : evalJs """
{
    "type": "Meta",
    "isPattern": true,
    "name": "name"
}"""

*Type
=== : eval: evalJs """
{
    "type": "Meta",
    "isList": true,
    "value_type": "`Type"
}
"""

name*
=== : evalJs """
{
    "type": "Meta",
    "isList": true,
    "name": "name"
}
"""

name&
=== : evalJs """
{
    "name": "name",
    "type": "Meta",
    "isRest": true,
    isList: true
}
"""

name?
=== : evalJs """
{
    "type": "Meta",
    "isOptional": true,
    "value": null,
    "name": "name"
}
"""


;; meta: name[Type]=value
i[Int]=1
=== : eval: evalJs """
{
    isList: false,
    type: "Meta",
    name: "i",
    value_type: "`Int",
    value: 1
}
"""


;; meta: just name
i[]
=== : evalJs """
{
    type: "Meta",
    name: "i"
}
"""


;; meta: just type
[Int]
=== : eval: evalJs """
{
    isList: false,
    type: "Meta",
    value_type: "`Int"
}
"""


;; meta: just value
[value=1]
=== : evalJs """
{
    type: "Meta",
    value: 1
}
"""


;; meta: just name and value
i=1
=== : evalJs """
{
    type: "Meta",
    name: "i",
    value: 1
}
"""


;; meta: with type as list
i[*Int]=1
=== : eval: evalJs """
{
    isList: true,
    type: "Meta",
    name: "i",
    value_type: "`Int",
    value: 1
}
"""


;; meta: with tick
`i=add
=== : eval: evalJs """
{
    isTick: true,
    type: "Meta",
    name: "i",
    value: "`add"
}
"""

;; meta: with quote
'i=add
=== : eval: evalJs """
{
    isQuote: true,
    type: "Meta",
    name: "i",
    value: "`add"
}
"""


;; meta: type whose value should be a function with no arguments that returns a boolean
f[Fn()[Bool]]
=== : eval: evalJs """
{
    isList: false,
    "type": "Meta",
    "name": "f",
    "value_type": "`Fn",
    "value_type_args": [
        [
            "`"
        ],
        {
            "type": "Meta",
            "value_type": "`Bool",
            "isList": false
        }
    ]
}"""


;; unnamed metas inside other metas will be added to the outer meta's value_type_args
[[Type]] ; declare a meta whose value_type_args has another meta
=== : eval: evalJs """
{
    type: "Meta",
    value_type_args:[
        {
            type: "Meta",
            value_type: "`Type",
            isList: false
        }
    ]
}
"""


;; test complex value
l=(list 1 2 3)
===: evalJs """
{
    "name": "l",
    "type": "Meta",
    "value": [
        1,
        2,
        3
    ]
}
"""


return _

;; todo test function with param types specified
fn times4 (x[Int])[Int]
	* x 4
times4 2 === 8
try
    times4 "2"
catch (e)
    "error"
=== "error"

