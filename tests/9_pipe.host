
; pipe: >> test basic functionality
1 >> add 1 === 2
1 >> + 2 === 3 >> / 3 === 1


; evalBlock: <<, test basic functionality
<<
	var i 2
	* i 2
=== 4
try
	add i
catch (err)
	"error"
=== "error"

; evalBlock: test inline lists
<< : add 1 1, >> * 2
=== 4


;; << -- parse correctly
parse "*
+ 2 <<
	3
4
*"
=== : evalJs "*
[
    "`",
    [
        "`",
        "`add",
        2,
        [
            "`",
            "`evalBlock",
            3
        ]
    ],
    4
]
*"


;*
;; test that pipe will check _ then _.type then context for function
fn toStr(o) : add "Name: " : || o.name o.Name o.Id

var Person : new
	type=Type
	name="Person"
Person.toStr : fn(p) : "I'm a Person named " + p.name

var p: new name="Mark"
p.type Person
p.toStr : fn(p): add "My name is Mark"

list
	<<
		p >> toStr
	<<
		p.toStr null
		p >> toStr
	<<
		p.type null
		p >> toStr
=== : list
    "My name is Mark"
    "I'm a Person named Mark"
    "Name: Mark"
*;


;; pipe second vs pipe first
"2" >>> add "1" "3" === "123"
"1" >> add "2" "3" === "123"

;; pipe into function that is looked up with getr
"1" >> utils.add 2 3 === "123"
"1" >>> utils.add 2 3 === "213"


;; make sure error occurs if piping to third position but no second value is specified
try
    parse "1 >>> push"
catch (err)
    "error"
=== "error"